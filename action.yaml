name: Trunk Check
author: trunk.io
description: The official trunk.io GitHub action

branding:
  icon: check
  color: green

inputs:
  trunk-path:
    description:
      Path to Trunk Launcher. If not provided, we'll look for it the repo root, `.trunk/bin` and
      `tools/`. If it can't be found anywhere and is not provided explicitly, we'll download it on
      demand.
    required: false

  label:
    description:
      Label to append to the check run name (useful if running Trunk Check on multiple platforms)
    deprecationMessage: "Use `arguments: --github-label=value` instead."
    required: false

  arguments:
    description: Extra arguments to pass to trunk
    required: false

  check-mode:
    description:
      Trunk check mode. Leave unset to autodetect. Set to 'all' to check the entire repository. Set
      to 'populate_cache_only' in a dedicated workflow to populate the GitHub Actions cache with
      Trunk artifacts (see docs for more details).
    required: false

  check-all-mode:
    description:
      If set to "hold-the-line", computes new/existing issues by comparing to previous upload.
    required: false
    default: ""

  check-run-id:
    description: Check run ID. If set, posts annotations using CheckService.
    required: false

  cache:
    description:
      Cache trunk downloads and results between runs. Caching is only needed when using ephemeral CI
      runners.
    required: false
    default: "true"

  cache-key:
    description:
      A key unique to the repo/branch this action is being run on (e.g. the repo name and branch)
    required: false

  post-init:
    description: Steps to run after auto-init / before check
    required: false

  github-token:
    description: For overriding github.token
    required: false

  trunk-token:
    description:
      You can find a per-repo API token in the Trunk web app settings. This will cause results to be
      uploaded to the Trunk web app if this job is a scheduled job running on a branch, or if
      `check-mode` is set to 'all'.
    required: false

  upload-series:
    description:
      Upload series name, for when `trunk-token` is provided. If not provided, we'll use the branch
      name.
    required: false

  save-annotations:
    description:
      Save annotations as an artifact instead of posting them from this action. This is neccesary if
      your repository will be used with forks as they will will not have permissions to upload
      annotations. By default forks will be auto-detected.
    required: false
    default: auto

  post-annotations:
    description:
      Post annotations previously uploaded with the `save-annotations` option (specific to posting
      annotations from forks).
    required: false
    default: "false"

  setup-deps:
    description:
      Install dependencies for trunk check that the trunk CLI does not manage. This is only
      necessary if you have Node dependencies in your package.json that your Node linters need (e.g.
      eslint dependencies, or @types packages).
    required: false
    default: "false"

  debug:
    description: Internal use only
    required: false
    default: "false"

runs:
  using: composite
  steps:
    - name: Input setup
      shell: bash
      run: |
        cat >>$GITHUB_ENV <<EOF
        GITHUB_TOKEN=${{ github.token }}
        EOF

        # Every inputs.field should be referenced as INPUT_FIELD later in the action. This allows
        # the field to be set either as an argument to the github action or via inputs.json.
        if [[ "${{ inputs.check-mode }}" = "payload" ]]; then

        INPUT_GITHUB_TOKEN=$(jq '.inputs.payload | fromjson | .githubToken // empty' $GITHUB_EVENT_PATH)
        INPUT_TRUNK_TOKEN=$(jq '.inputs.payload | fromjson | .trunkToken // empty' $GITHUB_EVENT_PATH)
        echo "::add-mask::${INPUT_GITHUB_TOKEN}"
        echo "::add-mask::${INPUT_TRUNK_TOKEN}"

          cat >>$GITHUB_ENV <<EOF
        INPUT_GITHUB_TOKEN=$INPUT_GITHUB_TOKEN
        INPUT_TRUNK_TOKEN=$INPUT_TRUNK_TOKEN
        GITHUB_EVENT_PULL_REQUEST_BASE_REPO_OWNER=$(jq 'inputs.payload | fromjson | .pullRequest.base.repo.owner.login //empty' $GITHUB_EVENT_PATH)
        GITHUB_EVENT_PULL_REQUEST_BASE_REPO_NAME=$(jq 'inputs.payload | fromjson | .pullRequest.base.repo.name //empty' $GITHUB_EVENT_PATH)
        GITHUB_EVENT_PULL_REQUEST_BASE_SHA=$(jq 'inputs.payload | fromjson | .pullRequest.base.sha //empty' $GITHUB_EVENT_PATH)
        GITHUB_EVENT_PULL_REQUEST_HEAD_REPO_FORK=$(jq 'inputs.payload | fromjson | .pullRequest.head.repo.fork //empty' $GITHUB_EVENT_PATH)
        GITHUB_EVENT_PULL_REQUEST_HEAD_SHA=$(jq 'inputs.payload | fromjson | .pullRequest.head.sha //empty' $GITHUB_EVENT_PATH)
        GITHUB_EVENT_PULL_REQUEST_NUMBER=$(jq 'inputs.payload | fromjson | .pullRequest.number //empty' $GITHUB_EVENT_PATH)
        INPUT_ARGUMENTS=$(jq 'inputs.payload | fromjson | .arguments //empty' $GITHUB_EVENT_PATH)
        INPUT_CACHE=$(jq 'inputs.payload | fromjson | .cache //empty' $GITHUB_EVENT_PATH)
        INPUT_CACHE_KEY=$(jq 'inputs.payload | fromjson | .cacheKey //empty' $GITHUB_EVENT_PATH)
        INPUT_CACHE_PATH=$(jq 'inputs.payload | fromjson | .cachePath //empty' $GITHUB_EVENT_PATH)
        INPUT_CHECK_ALL_MODE=$(jq 'inputs.payload | fromjson | .checkAllMode //empty' $GITHUB_EVENT_PATH)
        INPUT_CHECK_MODE=$(jq 'inputs.payload | fromjson | .checkMode //empty' $GITHUB_EVENT_PATH)
        INPUT_CHECK_RUN_ID=$(jq 'inputs.payload | fromjson | .checkRunId //empty' $GITHUB_EVENT_PATH)
        INPUT_DEBUG=$(jq 'inputs.payload | fromjson | .debug //empty' $GITHUB_EVENT_PATH)
        INPUT_GITHUB_REF_NAME=$(jq 'inputs.payload | fromjson | .targetRefName //empty' $GITHUB_EVENT_PATH)
        INPUT_LABEL=$(jq 'inputs.payload | fromjson | .label //empty' $GITHUB_EVENT_PATH)
        INPUT_SETUP_CACHE_KEY=$(jq 'inputs.payload | fromjson | .setupCacheKey //empty' $GITHUB_EVENT_PATH)
        INPUT_SETUP_DEPS=$(jq 'inputs.payload | fromjson | .setupDeps //empty' $GITHUB_EVENT_PATH)
        INPUT_TARGET_CHECKOUT=$(jq 'inputs.payload | fromjson | .targetCheckout //empty' $GITHUB_EVENT_PATH)
        INPUT_TARGET_CHECKOUT_REF=$(jq 'inputs.payload | fromjson | .targetCheckoutRef //empty' $GITHUB_EVENT_PATH)
        INPUT_TRUNK_PATH=$(jq 'inputs.payload | fromjson | .trunkPath //empty' $GITHUB_EVENT_PATH)
        INPUT_UPLOAD_LANDING_STATE=$(jq 'inputs.payload | fromjson | .uploadLandingState //empty' $GITHUB_EVENT_PATH)
        INPUT_UPLOAD_SERIES=$(jq 'inputs.payload | fromjson | .uploadSeries //empty' $GITHUB_EVENT_PATH)
        EOF

        else

        INPUT_GITHUB_TOKEN=${{ inputs.github-token }}
        INPUT_TRUNK_TOKEN=${{ inputs.trunk-token }}
        echo "::add-mask::${INPUT_GITHUB_TOKEN}"
        echo "::add-mask::${INPUT_TRUNK_TOKEN}"

          cat >>$GITHUB_ENV <<EOF
        INPUT_GITHUB_TOKEN=$INPUT_GITHUB_TOKEN
        INPUT_TRUNK_TOKEN=$INPUT_TRUNK_TOKEN
        GITHUB_EVENT_PULL_REQUEST_BASE_SHA=${{ github.event.pull_request.base.sha }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_REPO_FORK=${{ github.event.pull_request.head.repo.fork }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_SHA=${{ github.event.pull_request.head.sha }}
        GITHUB_EVENT_PULL_REQUEST_NUMBER=${{ github.event.pull_request.number }}
        GITHUB_REF_NAME=${{ github.ref_name }}
        INPUT_ARGUMENTS=${{ inputs.arguments }}
        INPUT_CACHE=${{ inputs.cache }}
        INPUT_CACHE_KEY=trunk-${{ inputs.cache-key }}-${{ runner.os }}-${{ hashFiles('.trunk/trunk.yaml') }}
        INPUT_CACHE_PATH=~/.cache/trunk
        INPUT_CHECK_ALL_MODE=${{ inputs.check-all-mode }}
        INPUT_CHECK_MODE=${{ inputs.check-mode }}
        INPUT_CHECK_RUN_ID=${{ inputs.check-run-id }}
        INPUT_DEBUG=${{ inputs.debug }}
        INPUT_GITHUB_REF_NAME=${{ github.ref_name }}
        INPUT_SETUP_DEPS=${{ inputs.setup-deps }}
        INPUT_TARGET_CHECKOUT=
        INPUT_TARGET_CHECKOUT_REF=
        INPUT_LABEL=${{ inputs.label }}
        INPUT_SETUP_CACHE_KEY=${{ inputs.cache-key }}
        INPUT_TRUNK_PATH=${{ inputs.trunk-path }}
        INPUT_UPLOAD_LANDING_STATE=false
        INPUT_UPLOAD_SERIES=${{ inputs.upload-series }}
        EOF

        fi

    - name: Checkout
      if: env.INPUT_TARGET_CHECKOUT
      uses: actions/checkout@v3
      with:
        lfs: true
        repository: ${{ env.INPUT_TARGET_CHECKOUT }}
        ref: ${{ env.INPUT_TARGET_CHECKOUT_REF }}
        token: ${{ env.INPUT_GITHUB_TOKEN }}

    - name: Locate trunk
      shell: bash
      run: ${GITHUB_ACTION_PATH}/locate_trunk.sh

    - name: Determine check mode
      shell: bash
      run: |
        # Determine check mode
        ${GITHUB_ACTION_PATH}/determine_check_mode.sh

    - name: Init on-demand
      shell: bash
      run: |
        if [ ! -e .trunk/trunk.yaml ]; then
          ${TRUNK_PATH:-trunk} init
        fi

    # This has to come before setup because setup can potentially take long time
    # (e.g. with bazel build) causing the github token used in fetching to expire
    - name: Fetch
      shell: bash
      run: ${GITHUB_ACTION_PATH}/fetch.sh

    - name: Detect setup strategy
      shell: bash
      run: |
        if [ -e .trunk/setup-ci ]; then
          echo "INPUT_SETUP_DEPS=true" >>$GITHUB_ENV
        else
          mkdir -p .trunk
          ln -s ${{ github.action_path }}/setup-env .trunk/setup-ci
          echo .trunk/setup-ci >>.git/info/exclude
        fi

    - name: Set up env
      uses: ./.trunk/setup-ci
      if: env.INPUT_SETUP_DEPS == 'true'
      with:
        cache-key: ${{ env.INPUT_SETUP_CACHE_KEY }}

    - name: Post-init steps
      if: inputs.post-init
      shell: bash
      run: ${{ inputs.post-init }}

    - name: Cache Linters/Formatters
      if: env.TRUNK_CHECK_MODE != 'none' && env.INPUT_CACHE == 'true'
      uses: actions/cache@v3
      with:
        path: ${{ env.INPUT_CACHE_PATH }}
        key: ${{ env.INPUT_CACHE_KEY }}

    - name: Run trunk check on pull request
      if: env.TRUNK_CHECK_MODE == 'pull_request'
      shell: bash
      run: |
        # Run 'trunk check' on pull request
        ${GITHUB_ACTION_PATH}/pull_request.sh
      env:
        INPUT_SAVE_ANNOTATIONS: ${{ inputs.save-annotations }}

    - name: Run trunk check on push
      if: env.TRUNK_CHECK_MODE == 'push'
      shell: bash
      run: |
        # Run 'trunk check' on push
        ${GITHUB_ACTION_PATH}/push.sh
      env:
        GITHUB_EVENT_AFTER: ${{ env.GITHUB_EVENT_AFTER || github.event.after }}
        GITHUB_EVENT_BEFORE: ${{ env.GITHUB_EVENT_BEFORE || github.event.before }}

    - name: Run trunk check on all
      if: env.TRUNK_CHECK_MODE == 'all'
      shell: bash
      run: |
        # Run 'trunk check' on all
        ${GITHUB_ACTION_PATH}/all.sh

    - name: Run trunk check on Trunk Merge
      if: env.TRUNK_CHECK_MODE == 'trunk_merge'
      shell: bash
      run: |
        # Run 'trunk check' on Trunk Merge
        ${GITHUB_ACTION_PATH}/trunk_merge.sh

    - name: Run trunk install to populate the GitHub Actions cache
      if: env.TRUNK_CHECK_MODE == 'populate_cache_only'
      shell: bash
      run: |
        # Run 'trunk install' to populate the GitHub Actions cache
        ${GITHUB_ACTION_PATH}/populate_cache_only.sh

    - name: Upload annotations artifact
      if: always() && env.TRUNK_UPLOAD_ANNOTATIONS == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: trunk-annotations
        path: ${{ env.TRUNK_TMPDIR }}/annotations.bin

    - name: Download annotations artifact
      if: inputs.post-annotations == 'true'
      uses: actions/github-script@v6
      with:
        # TODO(chris): We can't use the official download artifact action yet: https://github.com/actions/download-artifact/issues/172
        script: |
          let artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }},
          });
          let matchArtifact = artifacts.data.artifacts.filter((artifact) => {
            return artifact.name == "trunk-annotations"
          })[0];
          if (matchArtifact) {
            let download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: matchArtifact.id,
                archive_format: 'zip',
            });
            let fs = require('fs');
            fs.writeFileSync('${{ env.TRUNK_TMPDIR }}/annotations.zip', Buffer.from(download.data));
          }

    - name: Unpack annotations artifact
      if: inputs.post-annotations == 'true'
      run: |
        # Unpack annotations artifact
        cd ${{ env.TRUNK_TMPDIR }} && unzip annotations.zip
      shell: bash

    - name: Post annotations
      if: inputs.post-annotations == 'true'
      shell: bash
      run: |
        # Post annotations
        ${GITHUB_ACTION_PATH}/annotate.sh
      env:
        GITHUB_EVENT_WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}

    - name: Finalize check run
      if: always() && env.INPUT_CHECK_RUN_ID
      continue-on-error: true
      shell: bash
      run: |
        "${TRUNK_PATH}" check finalize-github-check-run \
          --target "${INPUT_TARGET_CHECKOUT}" \
          --check_run_id "${INPUT_CHECK_RUN_ID}" \

    - name: Upload landing state
      if: env.INPUT_UPLOAD_LANDING_STATE
      continue-on-error: true
      uses: actions/upload-artifact@v3
      with:
        name: landing-state.json
        path: .trunk/landing-state.json
        if-no-files-found: warn

    - name: Cleanup temporary files
      if: always()
      shell: bash
      run: |
        # Cleanup temporary files
        ${GITHUB_ACTION_PATH}/cleanup.sh
