name: Trunk Check
author: trunk.io
description: The official trunk.io GitHub action

branding:
  icon: check
  color: green

inputs:
  trunk-path:
    description:
      Path to Trunk Launcher. If not provided, we'll look for it the repo root, `.trunk/bin` and
      `tools/`. If it can't be found anywhere and is not provided explicitly, we'll download it on
      demand.
    required: false

  label:
    description:
      Label to append to the check run name (useful if running Trunk Check on multiple platforms)
    deprecationMessage: "Use `arguments: --github-label=value` instead."
    required: false

  arguments:
    description: Extra arguments to pass to trunk
    required: false

  check-mode:
    description:
      Trunk check mode. Leave unset to autodetect. Set to 'all' to check the entire repository. Set
      to 'populate_cache_only' in a dedicated workflow to populate the GitHub Actions cache with
      Trunk artifacts (see docs for more details).
    required: false

  check-all-mode:
    description:
      If set to "hold-the-line", computes new/existing issues by comparing to previous upload.
    required: false
    default: ""

  check-run-id:
    description: Check run ID. If set, posts annotations using CheckService.
    required: false

  cache:
    description:
      Cache trunk downloads and results between runs. Caching is only needed when using ephemeral CI
      runners.
    required: false
    default: "true"

  post-init:
    description: Steps to run after auto-init / before check
    required: false

  github-token:
    description: For overriding github.token
    required: false

  trunk-token:
    description:
      You can find a per-repo API token in the Trunk web app settings. This will cause results to be
      uploaded to the Trunk web app if this job is a scheduled job running on a branch, or if
      `check-mode` is set to 'all'.
    required: false

  upload-series:
    description:
      Upload series name, for when `trunk-token` is provided. If not provided, we'll use the branch
      name.
    required: false

  save-annotations:
    description:
      Save annotations as an artifact instead of posting them from this action. This is neccesary if
      your repository will be used with forks as they will will not have permissions to upload
      annotations. By default forks will be auto-detected.
    required: false
    default: auto

  post-annotations:
    description:
      Post annotations previously uploaded with the `save-annotations` option (specific to posting
      annotations from forks).
    required: false
    default: "false"

  json:
    description: Used by CheckService
    required: false
    default: "{}"

runs:
  using: composite
  steps:
    - name: Env setup
      shell: bash
      run: |
        echo "::add-mask::$INPUT_GITHUB_TOKEN"
        echo "::add-mask::$INPUT_TRUNK_TOKEN"

        cat >>$GITHUB_ENV <<EOF
        GITHUB_TOKEN=${{ github.token }}
        INPUT_GITHUB_TOKEN=$INPUT_GITHUB_TOKEN
        INPUT_TRUNK_TOKEN=$INPUT_TRUNK_TOKEN
        EOF

        # Every inputs.field should be referenced as INPUT_FIELD later in the action. This allows
        # the field to be set either as an argument to the github action or via inputs.json.
        if [[ -n "${{ fromJSON(inputs.json).version }}" ]]; then

          cat >>$GITHUB_ENV <<EOF
        GITHUB_EVENT_PULL_REQUEST_BASE_REPO_OWNER=${{ fromJSON(inputs.json).pullRequest.base.repo.owner.login }}
        GITHUB_EVENT_PULL_REQUEST_BASE_REPO_NAME=${{ fromJSON(inputs.json).pullRequest.base.repo.name }}
        GITHUB_EVENT_PULL_REQUEST_BASE_SHA=${{ fromJSON(inputs.json).pullRequest.base.sha }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_REPO_FORK=${{ fromJSON(inputs.json).pullRequest.head.repo.fork }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_SHA=${{ fromJSON(inputs.json).pullRequest.head.sha }}
        GITHUB_EVENT_PULL_REQUEST_NUMBER=${{ fromJSON(inputs.json).pullRequest.number }}
        INPUT_ARGUMENTS=${{ fromJSON(inputs.json).arguments }}
        INPUT_CACHE=${{ fromJSON(inputs.json).cache }}
        INPUT_CHECK_ALL_MODE=${{ fromJSON(inputs.json).checkAllMode }}
        INPUT_CHECK_MODE=${{ fromJSON(inputs.json).checkMode }}
        INPUT_CHECK_RUN_ID=${{ fromJSON(inputs.json).checkRunId }}
        INPUT_GITHUB_REF_NAME=${{ fromJSON(inputs.json).target.refName }}
        INPUT_LABEL=${{ fromJSON(inputs.json).label }}
        INPUT_TRUNK_PATH=${{ fromJSON(inputs.json).trunkPath }}
        INPUT_UPLOAD_SERIES=${{ fromJSON(inputs.json).uploadSeries }}
        EOF

        else

          cat >>$GITHUB_ENV <<EOF
        GITHUB_EVENT_PULL_REQUEST_BASE_SHA=${{ github.event.pull_request.base.sha }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_REPO_FORK=${{ github.event.pull_request.head.repo.fork }}
        GITHUB_EVENT_PULL_REQUEST_HEAD_SHA=${{ github.event.pull_request.head.sha }}
        GITHUB_EVENT_PULL_REQUEST_NUMBER=${{ github.event.pull_request.number }}
        GITHUB_REF_NAME=${{ github.ref_name }}
        INPUT_ARGUMENTS=${{ inputs.arguments }}
        INPUT_CACHE=${{ inputs.cache }}
        INPUT_CHECK_ALL_MODE=${{ inputs.check-all-mode }}
        INPUT_CHECK_MODE=${{ inputs.check-mode }}
        INPUT_CHECK_RUN_ID=${{ inputs.check-run-id }}
        INPUT_GITHUB_REF_NAME=${{ github.ref_name }}
        INPUT_LABEL=${{ inputs.label }}
        INPUT_TRUNK_PATH=${{ inputs.trunk-path }}
        INPUT_UPLOAD_SERIES=${{ inputs.upload_series }}
        EOF

        fi
      env:
        # These are handled specially because we add-mask them.
        INPUT_GITHUB_TOKEN: ${{ inputs.github-token || fromJSON(inputs.json).githubToken }}
        INPUT_TRUNK_TOKEN: ${{ inputs.trunk-token || fromJSON(inputs.json).token }}

    - name: Locate trunk
      shell: bash
      run: ${GITHUB_ACTION_PATH}/locate_trunk.sh

    - name: Init on-demand
      shell: bash
      run: |
        if [ ! -e .trunk/trunk.yaml ]; then
          ${TRUNK_PATH} init
        fi

    - name: Detect npm/yarn/pnpm
      id: detect
      shell: bash
      run: |
        if [ -e package-lock.json ]; then
          echo "package_manager=npm" >> $GITHUB_OUTPUT
          echo "install_cmd=npm ci" >> $GITHUB_OUTPUT
          echo "hash_glob=**/package-lock.json" >> $GITHUB_OUTPUT
        elif [ -e yarn.lock ]; then
          echo "package_manager=yarn" >> $GITHUB_OUTPUT
          echo "install_cmd=yarn install --immutable" >> $GITHUB_OUTPUT
          echo "hash_glob=**/yarn.lock" >> $GITHUB_OUTPUT
        elif [ -e pnpm-lock.yaml ]; then
          echo "package_manager=pnpm" >> $GITHUB_OUTPUT
          echo "install_cmd=pnpm install --frozen-lockfile" >> $GITHUB_OUTPUT
          echo "hash_glob=**/pnpm-lock.yaml" >> $GITHUB_OUTPUT
        fi

    - name: Install pnpm
      if: steps.detect.outputs.package_manager == 'pnpm'
      uses: pnpm/action-setup@v2
      with:
        version: latest

    - name: Install Node dependencies
      if: steps.detect.outputs.package_manager
      uses: actions/setup-node@v3

    #- name: Cache node_modules
    #  uses: actions/cache@v3
    #  with:
    #    path: node_modules/
    #    key: ${{ runner.os }}-node_modules-${{ hashFiles(steps.detect.outputs.hash_glob) }}

    - name: Install ${{ steps.detect.outputs.package_manager }} packages
      if: steps.detect.outputs.package_manager
      shell: bash
      run: ${{ steps.detect.outputs.install_cmd }}

    - name: Post-init steps
      if: inputs.post-init
      shell: bash
      run: ${{ inputs.post-init }}

    - name: Determine check mode
      shell: bash
      run: |
        # Determine check mode
        ${GITHUB_ACTION_PATH}/determine_check_mode.sh

    - name: Cache Linters/Formatters
      if: env.TRUNK_CHECK_MODE != 'none' && env.INPUT_CACHE == 'true'
      uses: actions/cache@v3
      with:
        path: ~/.cache/trunk
        key: trunk-${{ runner.os }}-${{ hashFiles('.trunk/trunk.yaml') }}

    - name: Run trunk check on pull request
      if: env.TRUNK_CHECK_MODE == 'pull_request'
      shell: bash
      run: |
        # Run 'trunk check' on pull request
        ${GITHUB_ACTION_PATH}/pull_request.sh
      env:
        INPUT_SAVE_ANNOTATIONS: ${{ inputs.save-annotations }}

    - name: Run trunk check on push
      if: env.TRUNK_CHECK_MODE == 'push'
      shell: bash
      run: |
        # Run 'trunk check' on push
        ${GITHUB_ACTION_PATH}/push.sh
      env:
        GITHUB_EVENT_AFTER: ${{ env.GITHUB_EVENT_AFTER || github.event.after }}
        GITHUB_EVENT_BEFORE: ${{ env.GITHUB_EVENT_BEFORE || github.event.before }}

    - name: Run trunk check on all
      if: env.TRUNK_CHECK_MODE == 'all'
      shell: bash
      run: |
        # Run 'trunk check' on all
        ${GITHUB_ACTION_PATH}/all.sh

    - name: Run trunk check on Trunk Merge
      if: env.TRUNK_CHECK_MODE == 'trunk_merge'
      shell: bash
      run: |
        # Run 'trunk check' on Trunk Merge
        ${GITHUB_ACTION_PATH}/trunk_merge.sh

    - name: Run trunk install to populate the GitHub Actions cache
      if: env.TRUNK_CHECK_MODE == 'populate_cache_only'
      shell: bash
      run: |
        # Run 'trunk install' to populate the GitHub Actions cache
        ${GITHUB_ACTION_PATH}/populate_cache_only.sh

    - name: Upload annotations artifact
      if: always() && env.TRUNK_UPLOAD_ANNOTATIONS == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: trunk-annotations
        path: ${{ env.TRUNK_TMPDIR }}/annotations.bin

    - name: Download annotations artifact
      if: inputs.post-annotations == 'true'
      uses: actions/github-script@v6
      with:
        # TODO(chris): We can't use the official download artifact action yet: https://github.com/actions/download-artifact/issues/172
        script: |
          let artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }},
          });
          let matchArtifact = artifacts.data.artifacts.filter((artifact) => {
            return artifact.name == "trunk-annotations"
          })[0];
          if (matchArtifact) {
            let download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: matchArtifact.id,
                archive_format: 'zip',
            });
            let fs = require('fs');
            fs.writeFileSync('${{ env.TRUNK_TMPDIR }}/annotations.zip', Buffer.from(download.data));
          }

    - name: Unpack annotations artifact
      if: inputs.post-annotations == 'true'
      run: |
        # Unpack annotations artifact
        cd ${{ env.TRUNK_TMPDIR }} && unzip annotations.zip
      shell: bash

    - name: Post annotations
      if: inputs.post-annotations == 'true'
      shell: bash
      run: |
        # Post annotations
        ${GITHUB_ACTION_PATH}/annotate.sh
      env:
        GITHUB_EVENT_WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}

    - name: Finalize check run
      if: always() && env.INPUT_CHECK_RUN_ID
      continue-on-error: true
      uses: actions/github-script@v6
      with:
        github-token: ${{ env.INPUT_GITHUB_TOKEN }}
        script: |
          console.log("Verifying that the GitHub check run was updated with results...");
          const { data } = await github.rest.checks.get({
            owner: "${{ env.GITHUB_EVENT_PULL_REQUEST_BASE_REPO_OWNER }}",
            repo: "${{ env.GITHUB_EVENT_PULL_REQUEST_BASE_REPO_NAME }}",
            check_run_id: ${{ env.INPUT_CHECK_RUN_ID }}
          });
          if (data.status === "completed") {
            console.log("Success!");
            return;
          }
          console.log(`::group::Status was ${data.status}; marking the check run as failed.`);
          console.log(data);
          console.log("::endgroup::");
          await github.rest.checks.update({
            owner: "${{ env.GITHUB_EVENT_PULL_REQUEST_BASE_REPO_OWNER }}",
            repo: "${{ env.GITHUB_EVENT_PULL_REQUEST_BASE_REPO_NAME }}",
            check_run_id: ${{ env.INPUT_CHECK_RUN_ID }},
            head_sha: "${{ env.GITHUB_EVENT_PULL_REQUEST_HEAD_SHA }}",
            status: "completed",
            conclusion: "failure",
            output: {
              title: "Trunk Check",
              summary: "unexpected failure",
              text: "Please contact us at https://slack.trunk.io to get help",
            },
          });

    - name: Cleanup temporary files
      if: always()
      shell: bash
      run: |
        # Cleanup temporary files
        ${GITHUB_ACTION_PATH}/cleanup.sh
