name: Trunk Check
author: trunk.io
description: The official trunk.io GitHub action

branding:
  icon: check
  color: green

inputs:
  trunk-path:
    description:
      Path to Trunk Launcher. If not provided, we'll look for it the repo root, `.trunk/bin` and
      `tools/`. If it can't be found anywhere and is not provided explicitly, we'll download it on
      demand.
    required: false

  label:
    description:
      Label to append to the check run name (useful if running Trunk Check on multiple platforms)
    deprecationMessage: "Use `arguments: --github-label=value` instead."
    required: false

  arguments:
    description: Extra arguments to pass to trunk
    required: false

  check-mode:
    description:
      Trunk check mode. Leave unset to autodetect. Set to 'all' to check the entire repository. Set
      to 'populate_cache_only' in a dedicated workflow to populate the GitHub Actions cache with
      Trunk artifacts (see docs for more details).
    required: false

  check-all-mode:
    description:
      If set to "hold-the-line", computes new/existing issues by comparing to previous upload.
    required: false
    default: ""

  check-run-id:
    description: Check run ID. If set, posts annotations using CheckService.
    required: false

  cache:
    description:
      Cache trunk downloads and results between runs. Caching is only needed when using ephemeral CI
      runners.
    required: false
    default: "true"

  cache-key:
    description:
      A key unique to the repo/branch this action is being run on (e.g. the repo name and branch)
    required: false

  post-init:
    description: Steps to run after auto-init / before check
    required: false

  github-token:
    description: For overriding github.token
    required: false

  trunk-token:
    description:
      You can find a per-repo API token in the Trunk web app settings. This will cause results to be
      uploaded to the Trunk web app if this job is a scheduled job running on a branch, or if
      `check-mode` is set to 'all'.
    required: false

  upload-series:
    description:
      Upload series name, for when `trunk-token` is provided. If not provided, we'll use the branch
      name.
    required: false

  save-annotations:
    description:
      Save annotations as an artifact instead of posting them from this action. This is neccesary if
      your repository will be used with forks as they will will not have permissions to upload
      annotations. By default forks will be auto-detected.
    required: false
    default: auto

  post-annotations:
    description:
      Post annotations previously uploaded with the `save-annotations` option (specific to posting
      annotations from forks).
    required: false
    default: "false"

  setup-deps:
    description:
      Install dependencies for trunk check that the trunk CLI does not manage. This is only
      necessary if you have Node dependencies in your package.json that your Node linters need (e.g.
      eslint dependencies, or @types packages).
    required: false
    default: "false"

  json:
    description: Used by CheckService
    required: false
    default: "{}"

  debug:
    description: Internal use only
    required: false
    default: "false"

runs:
  using: composite
  steps:
    - name: Set up inputs
      shell: python
      run: |
        from os import environ
        import json

        github_env_path = environ.get('GITHUB_ENV', None)
        if github_env_path == None:
          raise OSError("GITHUB_ENV doesn't exist!")
        github_env = open(github_env_path, "w")

        github_event_filepath = environ.get('GITHUB_EVENT_PATH', "")
        if "${{ inputs.check-mode }}" == "payload" and github_event_filepath != "":
          github_event_text = open(github_event_filepath).read()
          inputs_dict = json.loads(github_event_text)["inputs"]
          client_payload = json.loads(inputs_dict.get("payload", inputs_dict.get("clientPayload", None)))
          githubToken = client_payload["githubToken"]
          trunkToken = client_payload.get("trunkToken", client_payload.get("token", ""))
        else:
          githubToken = "${{ inputs.github-token || fromJSON(inputs.json).githubToken }}"
          trunkToken = "${{ inputs.trunk-token || fromJSON(inputs.json).trunkToken || fromJSON(inputs.json).token }}"
          try:
            client_payload = json.loads('${{ inputs.json }}') # these must be single quotes
          except json.decoder.JSONDecodeError:
            client_payload = None

        print(f"::add-mask::{githubToken}")
        print(f"::add-mask::{trunkToken}")

        github_env.write("GITHUB_TOKEN=${{ github.token }}\n")
        github_env.write(f"INPUT_GITHUB_TOKEN={githubToken}\n")
        github_env.write(f"INPUT_TRUNK_TOKEN={trunkToken}\n")

        def env_write(payload, varname, path, backup):
          to_write = payload
          for arg in path.split("."):
            if to_write is None or type(to_write) != dict:
              to_write = backup
              break
            to_write = to_write.get(arg, backup)

          if to_write in [True, False]:
            to_write = str(to_write).lower()
          github_env.write(f"{varname}={to_write}\n")

        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_BASE_REPO_OWNER", "pullRequest.base.repo.owner.login", "")
        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_BASE_REPO_NAME", "pullRequest.base.repo.name", "")
        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_BASE_SHA", "pullRequest.base.sha", "${{ github.event.pull_request.base.sha }}")
        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_HEAD_REPO_FORK", "pullRequest.head.repo.fork", "${{ github.event.pull_request.head.repo.fork }}")
        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_HEAD_SHA", "pullRequest.head.sha", "${{ github.event.pull_request.head.sha }}")
        env_write(client_payload, "GITHUB_EVENT_PULL_REQUEST_NUMBER", "pullRequest.number", "${{ github.event.pull_request.number }}")
        env_write(client_payload, "GITHUB_REF_NAME", "targetRefName", "${{ github.ref_name }}")
        env_write(client_payload, "INPUT_ARGUMENTS", "arguments", "${{ inputs.arguments }}")
        env_write(client_payload, "INPUT_CACHE", "cache", "${{ inputs.cache }}")
        env_write(client_payload, "INPUT_CACHE_KEY", "cacheKey", "trunk-${{ inputs.cache-key }}-${{ runner.os }}-${{ hashFiles('.trunk/trunk.yaml') }}")
        env_write(client_payload, "INPUT_CACHE_PATH", "cachePath", "~/.cache/trunk")
        env_write(client_payload, "INPUT_CHECK_ALL_MODE", "checkAllMode", "${{ inputs.check-all-mode }}")
        env_write(client_payload, "INPUT_CHECK_MODE", "checkMode", "${{ inputs.check-mode }}")
        env_write(client_payload, "INPUT_CHECK_RUN_ID", "checkRunId", "${{ inputs.check-run-id }}")
        env_write(client_payload, "INPUT_DEBUG", "debug", "${{ inputs.debug }}")
        env_write(client_payload, "INPUT_GITHUB_REF_NAME", "targetRefName", "${{ github.ref_name }}")
        env_write(client_payload, "INPUT_LABEL", "label", "${{ inputs.label }}")
        env_write(client_payload, "INPUT_SETUP_CACHE_KEY", "setupCacheKey", "${{ inputs.cache-key }}")
        env_write(client_payload, "INPUT_SETUP_DEPS", "setupDeps", "${{ inputs.setup-deps }}")
        env_write(client_payload, "INPUT_TARGET_CHECKOUT", "targetCheckout", "")
        env_write(client_payload, "INPUT_TARGET_CHECKOUT_REF", "targetCheckoutRef", "")
        env_write(client_payload, "INPUT_TRUNK_PATH", "trunkPath", "${{ inputs.trunk-path }}")
        env_write(client_payload, "INPUT_UPLOAD_LANDING_STATE", "uploadLandingState", "false")
        env_write(client_payload, "INPUT_UPLOAD_SERIES", "uploadSeries", "${{ inputs.upload-series }}")

    - name: Checkout
      if: env.INPUT_TARGET_CHECKOUT
      uses: actions/checkout@v3
      with:
        repository: ${{ env.INPUT_TARGET_CHECKOUT }}
        ref: ${{ env.INPUT_TARGET_CHECKOUT_REF }}
        token: ${{ env.INPUT_GITHUB_TOKEN }}

    - name: Locate trunk
      shell: bash
      run: ${GITHUB_ACTION_PATH}/locate_trunk.sh

    - name: Determine check mode
      shell: bash
      run: |
        # Determine check mode
        ${GITHUB_ACTION_PATH}/determine_check_mode.sh

    # This has to come before setup because setup can potentially take long time
    # (e.g. with bazel build) causing the github token used in fetching to expire
    - name: Fetch
      shell: bash
      run: ${GITHUB_ACTION_PATH}/fetch.sh

    - name: Detect setup strategy
      shell: bash
      run: |
        if [ -e .trunk/setup-ci ]; then
          echo "INPUT_SETUP_DEPS=true" >>$GITHUB_ENV
        else
          mkdir -p .trunk
          ln -s ${{ github.action_path }}/setup-env .trunk/setup-ci
          echo .trunk/setup-ci >>.git/info/exclude
        fi

    - name: Set up env
      uses: ./.trunk/setup-ci
      if: env.INPUT_SETUP_DEPS == 'true'
      with:
        cache-key: ${{ env.INPUT_SETUP_CACHE_KEY }}

    - name: Init on-demand
      shell: bash
      run: |
        if [ ! -e .trunk/trunk.yaml ]; then
          ${TRUNK_PATH:-trunk} init
        fi

    - name: Post-init steps
      if: inputs.post-init
      shell: bash
      run: ${{ inputs.post-init }}

    - name: Cache Linters/Formatters
      if: env.TRUNK_CHECK_MODE != 'none' && env.INPUT_CACHE == 'true'
      uses: actions/cache@v3
      with:
        path: ${{ env.INPUT_CACHE_PATH }}
        key: ${{ env.INPUT_CACHE_KEY }}

    - name: Run trunk check on pull request
      if: env.TRUNK_CHECK_MODE == 'pull_request'
      shell: bash
      run: |
        # Run 'trunk check' on pull request
        ${GITHUB_ACTION_PATH}/pull_request.sh
      env:
        INPUT_SAVE_ANNOTATIONS: ${{ inputs.save-annotations }}

    - name: Run trunk check on push
      if: env.TRUNK_CHECK_MODE == 'push'
      shell: bash
      run: |
        # Run 'trunk check' on push
        ${GITHUB_ACTION_PATH}/push.sh
      env:
        GITHUB_EVENT_AFTER: ${{ env.GITHUB_EVENT_AFTER || github.event.after }}
        GITHUB_EVENT_BEFORE: ${{ env.GITHUB_EVENT_BEFORE || github.event.before }}

    - name: Run trunk check on all
      if: env.TRUNK_CHECK_MODE == 'all'
      shell: bash
      run: |
        # Run 'trunk check' on all
        ${GITHUB_ACTION_PATH}/all.sh

    - name: Run trunk check on Trunk Merge
      if: env.TRUNK_CHECK_MODE == 'trunk_merge'
      shell: bash
      run: |
        # Run 'trunk check' on Trunk Merge
        ${GITHUB_ACTION_PATH}/trunk_merge.sh

    - name: Run trunk install to populate the GitHub Actions cache
      if: env.TRUNK_CHECK_MODE == 'populate_cache_only'
      shell: bash
      run: |
        # Run 'trunk install' to populate the GitHub Actions cache
        ${GITHUB_ACTION_PATH}/populate_cache_only.sh

    - name: Upload annotations artifact
      if: always() && env.TRUNK_UPLOAD_ANNOTATIONS == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: trunk-annotations
        path: ${{ env.TRUNK_TMPDIR }}/annotations.bin

    - name: Download annotations artifact
      if: inputs.post-annotations == 'true'
      uses: actions/github-script@v6
      with:
        # TODO(chris): We can't use the official download artifact action yet: https://github.com/actions/download-artifact/issues/172
        script: |
          let artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }},
          });
          let matchArtifact = artifacts.data.artifacts.filter((artifact) => {
            return artifact.name == "trunk-annotations"
          })[0];
          if (matchArtifact) {
            let download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: matchArtifact.id,
                archive_format: 'zip',
            });
            let fs = require('fs');
            fs.writeFileSync('${{ env.TRUNK_TMPDIR }}/annotations.zip', Buffer.from(download.data));
          }

    - name: Unpack annotations artifact
      if: inputs.post-annotations == 'true'
      run: |
        # Unpack annotations artifact
        cd ${{ env.TRUNK_TMPDIR }} && unzip annotations.zip
      shell: bash

    - name: Post annotations
      if: inputs.post-annotations == 'true'
      shell: bash
      run: |
        # Post annotations
        ${GITHUB_ACTION_PATH}/annotate.sh
      env:
        GITHUB_EVENT_WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}

    - name: Finalize check run
      if: always() && env.INPUT_CHECK_RUN_ID
      continue-on-error: true
      shell: bash
      run: |
        "${TRUNK_PATH}" check finalize-github-check-run \
          --target "${INPUT_TARGET_CHECKOUT}" \
          --check_run_id "${INPUT_CHECK_RUN_ID}" \
          --token "${INPUT_TRUNK_TOKEN}"

    - name: Upload landing state
      if: env.INPUT_UPLOAD_LANDING_STATE
      continue-on-error: true
      uses: actions/upload-artifact@v3
      with:
        name: landing-state.json
        path: .trunk/landing-state.json
        if-no-files-found: warn

    - name: Cleanup temporary files
      if: always()
      shell: bash
      run: |
        # Cleanup temporary files
        ${GITHUB_ACTION_PATH}/cleanup.sh
